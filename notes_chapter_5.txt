Chapter 5: Types

- Every value (irreducible expression) has a type.
- In Haskell, there is no untyped data
  -> every data ordinates in a data ctor from a typedef!

Strong typing == not allowing cetrain errors
Static typing == types are known at compile time

Type inference -> deducing types of untyped variables
                  from expressions.

Command :t is :type!

    :t True ---> True :: Bool
but :t 13   ---> 13 :: Num a => a
                       what is it? polymorphic value!

Type signature of functions? Example:
    :t not
    not :: Bool -> Bool

-> : arrow, type constructor for functions.

     Yes, it is also a type ctor like Bool, but it
     takes arguments and has no data ctors:
        :i Bool
        data Bool = False | True

        :i (->)
        data (->) a b
     Since it has no data ctors, the value of type
     is the function! Functions are values!!!

,  : type ctor for two-tuple, similar:
        :i (,)
        data (,) a b = (,) a b

Type signatures in GHC 7.10:
   old: [a] -> Int
   new: Foldable t => t a -> Int

        !!polymorphism!! not just for lists, but for all
        instances of the Foldable (type)class. 

Type signatures with multiple typeclasses:
   (Num a, Num b) => a -> b -> b

   - no other argument, don't appear like a tuple at value,term
     level, !!!just multiple (typeclass) constraints!!!

Currying:
   lambda expressions with multiple parameters
      == just nested lambdas

      fff :: Integer -> Integer -> Integer
      fff :: Integer -> ( Integer -> Integer )
             ~~~~~~~~~~~~~
                 the function takes a number, and returns
                 an other function -- PARTIAL APPLICATION!
     
      Remember:
         lam xy.~~ = lam x.(lam y.~~)
         f(x,y) = (f'(x))(y)          ~~~~ hard to imagine

  Another example, in blah.hs
       blah :: a -> a -> a -> String
       blah x y z = "Blah"

       a -> ( a ->  a -> String )
              a -> (a -> String )
                    a -> String
       f(x,y,z)=((f'(x))(y))(z)

Uncurrying:
     uncurried - 1 function, more arguments in a tuple
     curried   - many functions, 1 argument for each

     automatic vs. manual nesting in curry_uncurry.hs!

     

Page 149
