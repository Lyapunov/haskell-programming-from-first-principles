First-class value: value which can be used as an argument to a
function.

Literal value is not applied on arguments, functions are.

Binding vairables to values:
 - applying parameter to an argument is binding it to a
   type (concrete, constrainted polymorphic).
 - applying the parameter to a value is binding it to a
   value.

Shadowing;
   func :: Integer -> Integer
   func x = let x = 10; y = ....
   !!! x will be 10 !!!

Anonymous functions:
 - Lambda syntax, backslash in the front of x
     (\x -> x * 3) :: Integer -> Integer
   Try (\x -> x* 3) 1
   And (\x -> \y -> x + y) 5 3

Note: ghci block syntax: :{ and :}

Pattern matching:
 - patterns match  unified variables, numeric literals,
   list syntax. (On any and all data ctors.)
 - agaist variables, not types!
 - having a set of patterns, if one fails, proceeding 
   to the next available pattern.
 - pattern matching proceeds left to right and outside to
   inside.
 - try to order your patterns from most specific to least
   specific.
 - if patterns don't cover all possible cases
    -> partial functions, may cause exceptions!!!
   use :set -Wall to detect them!
 - Ideas:
     - defining a function case by case
     - unpacking datatypes

Pattern matching tuples:
 - pattern match also works for tuples, it makes life easier.

Case expressions:
 - func verdictOfMoneyBalance x =
      case x > 1000 of
         True -> "Great"
         False -> "Not so great"

Higher-order functions:
 - functions which take other function(s) as argument(s)
 - flip is a simple example. Eg.
   compare 5 4
   vs. (flip compare) 5 4

Page 245
