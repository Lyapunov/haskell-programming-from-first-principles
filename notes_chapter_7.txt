First-class value: value which can be used as an argument to a
function.

Literal value is not applied on arguments, functions are.

Binding vairables to values:
 - applying parameter to an argument is binding it to a
   type (concrete, constrainted polymorphic).
 - applying the parameter to a value is binding it to a
   value.

Shadowing;
   func :: Integer -> Integer
   func x = let x = 10; y = ....
   !!! x will be 10 !!!

Anonymous functions:
 - Lambda syntax, backslash in the front of x
     (\x -> x * 3) :: Integer -> Integer
   Try (\x -> x* 3) 1
   And (\x -> \y -> x + y) 5 3

Note: ghci block syntax: :{ and :}

Pattern matching:
 - patterns match  unified variables, numeric literals,
   list syntax. (On any and all data ctors.)
 - agaist variables, not types!
 - having a set of patterns, if one fails, proceeding 
   to the next available pattern.
 - pattern matching proceeds left to right and outside to
   inside.
 - try to order your patterns from most specific to least
   specific.
 - if patterns don't cover all possible cases
    -> partial functions, may cause exceptions!!!
   use :set -Wall to detect them!
 - Ideas:
     - defining a function case by case
     - unpacking datatypes

Pattern matching tuples:
 - pattern match also works for tuples, it makes life easier.

Case expressions:
 - func verdictOfMoneyBalance x =
      case x > 1000 of
         True -> "Great"
         False -> "Not so great"

Higher-order functions:
 - functions which take other function(s) as argument(s)
 - flip is a simple example. Eg.
   compare 5 4
   vs. (flip compare) 5 4

GUARDS:
 - relies on truth values to decide between two or more
   possible results.
 - if / then / else is an example for guards
 - GUARD BLOCKS with pipe (it is |):
    - the equal sign is not in the front but after each
      case
    - otherwise is just another name for true, in ghci:
      > otherwise
      True

Function composition:
 - Basic syntax of composition operator:
     ( f . g ) x = f( g x )  [ f is b -> c, g is a -> b ]
 - Precedence can be awkward, because applying the function
   has higher precedence than . ( $ is recommended. )
 - Why is it cool: it makes easy to compose more than
   two functions.
       take 5 . filter odd . enumFrom $ 3

Page 254
