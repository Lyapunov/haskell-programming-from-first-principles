The list datatype
~~~~~~~~~~~~~~~~~
Definitions is something like
   data [] a = [] | a : [a]

[] is the type ctor of the list and the data ctor of the empty list. 
: is an infix operator, 'cons' (constructs(.

'The list datatype is either an empty list or a single value
with more list"

Pattern match
~~~~~~~~~~~~~
We know we can pattern match data ctors -> [] and : !

-> Consider the type Maybe for making functions complete and safe
data Maybe a = Nothing | Just a

Syntactic sugar
~~~~~~~~~~~~~~~
[1,2,3] ++ [4] instead of ( 1 : 2 : 3 : [] ) ++ 4 : [] 
                          ( const cells, spines )

Using ranges
~~~~~~~~~~~~
They are sugars for enumFromTo, enumFromThenTo
[1..10], and [1,3..10] == [1,3,5,7,9]

works on >Enum<s:
['a'..'z']
['a','d'..'z']

- There enumFrom and enumFromThen, they create potentially infinitely
  long lists. That requires a type without upper limit, Integer is
  a good candidate.
- if second argument is lower than the first => empty list

Extracting portions of lists
~~~~~~~~~~~~~~~~~~~~~~~~~~~~
take (x items from list), drop (x items from lists),
splitAt (x is the positionn))
  - something less meaningful with these -> empty list
    eg. splitAt 5 [] => ([],[])

takeWhile, dropWhile -> they use conditions

List comprehensions
~~~~~~~~~~~~~~~~~~~
Its basically map(ping), generating a list from an existing one.
   [ x^2 | x <- [1..10] ]

Adding predicates:
   [ x^2 | x <- [1..10], rem x 2 == 0 ]
multiple generators: (right -> left counter handling)
   [ x*y | x <- [1..3], y <- [1..3]]
or adding both:
   [ x*y | x <- [1..3], y <- [1..3], rem (x+y) 2 == 0]

With strings:
First thing is elem, elem 'x' "xyz" == True.

Spine structure of list
~~~~~~~~~~~~~~~~~~~~~~~
  :
 / \
1  :     is [1,2,...]
  / \
 2   ...

:sprint
~~~~~~~
Allows to see what is evaluated already, but can be complicated
to use. An example (not easy to find another, polymorphism kills it,
numbers will fail by default)):
>let blah = enumFrom 'a' 'z'
>take 5 blah
>:sprint blah

Spines are evaluated independently of values
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
WHNF -- weak head normal form
     NF --- fully evaluated
   WHNF --- evaluated only as far to reach a data ctor

evaluating the spine without values: length is the example

another thing to contemplate is that there can be problems with spine
   let z = [1,2,3] ++ undefined ++ [4,5,6]


Transforming list of values
~~~~~~~~~~~~~~~~~~~~~~~~~~~
map vs. fmap. fmap means 'functor map'.

- about evaluation. !!!map doesn't actually traverse the whole list
  immediately, the function is applied to the values which are forced out
  of the list one by one!!!
  > take 1 $ map (+1) [1, undefined, 3]
  is valid.

Page 321
